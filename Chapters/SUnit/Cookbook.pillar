!!The SUnit cookbook

This chapter will give you more details on how to use SUnit. If you have used
another testing framework such as JUnit, much of this will be familiar, since
all these frameworks have their roots in SUnit. Normally you will use SUnit's
GUI to run tests, but there are situations where you may not want to use it.


!!!Other assertions

In addition to ==assert:== and ==deny:==, there are several other methods that
can be used to make assertions.

First, ==TestAsserter >> assert:description:== and ==TestAsserter >>
deny:description:== take a second argument which is a message string that
describes the reason for the failure, if it is not obvious from the test itself.
These methods are described in Section *@sec:descriptionStrings*.

Next, SUnit provides two additional methods, ==TestAsserter >> should:raise:==
and ==TestAsserter >> shouldnt:raise:== for testing exception propagation.

For example, you would use ==self should: aBlock raise: anException== to test
that a particular exception is raised during the execution of ==aBlock==. The
method below illustrates the use of ==should:raise:==.

[[[caption=Testing error raising
	MyExampleSetTest >> testIllegal
		self should: [ empty at: 5 ] raise: Error.
		self should: [ empty at: 5 put: #zork ] raise: Error
]]]

Try running this test. Note that the first argument of the ==should:== and
==shouldnt:== methods is a block that contains the expression to be executed.


!!!Using ==assert:equals:==

In addition to ==assert:==, there is also ==assert:equals:== that offers a
better report in case of error (incidentally, ==assert:equals:== uses
==assert:description:==).

For example, the two following tests are equivalent. However, the second one
will report the value that the test is expecting: this makes easier to
understand the failure. In this example, we suppose that ==aDateAndTime== is an
instance variable of the test class.

[[[
testAsDate
	self assert: aDateAndTime asDate = ('February 29, 2004' asDate translateTo: 2 hours).

testAsDate
	self
		assert: aDateAndTime asDate
		equals: ('February 29, 2004' asDate translateTo: 2 hours).
]]]


!!!Assertion description strings
@sec:descriptionStrings

The ==TestAsserter== assertion protocol includes a number of methods that allow
the programmer to supply a description of the assertion. The description is a
==String==; if the test case fails, this string will be displayed by the test
runner. Of course, this string can be constructed dynamically.

[[[
...
e := 42.
self assert: e = 23 description: 'expected 23, got ', e printString
...
]]]

The relevant methods in ==TestAsserter== are:

[[[
assert:description:
deny:description:
should:description:
shouldnt:description:
]]]

!!!Running a single test

Normally, you will run your tests using the Test Runner or using your code
browser. If you don't want to launch the Test Runner from the World menu, you
can execute ==TestRunner open==. You can also run a single test as follows:

[[[testcase=true
MyExampleSetTest run: #testRemove
>>> 1 run, 1 passed, 0 failed, 0 errors
]]]

!!!Running all the tests in a test class

Any subclass of ==TestCase== responds to the message ==suite==, which will build
a test suite that contains all the methods in the class whose names start with
the string ''test''.

To run the tests in the suite, send it the message ==run==. For example:

[[[testcase=true
MyExampleSetTest suite run
>>> 5 run, 5 passed, 0 failed, 0 errors
]]]

!!!Must I subclass TestCase?

In JUnit you can build a TestSuite from an arbitrary class containing ==test*==
methods. In SUnit you can do the same but you will then have to create a suite
by hand and your class will have to implement all the essential ==TestCase==
methods like ==assert:==. We recommend, however, that you not try to do this.
The framework is there: use it.




!!!Advanced features of SUnit

In addition to ==TestResource==, SUnit contains assertion description strings,
logging support, the ability to skip tests, and resumable test failures.


!!!!Logging support

The description strings mentioned above may also be logged to a ==Stream==, such
as the ==Transcript== or a file stream. You can choose whether to log by
overriding ==isLogging== in your test class; you must also choose where to log
by overriding ==failureLog== to answer an appropriate stream. By default, the
==Transcript== is used to log.

!!!!Skipping tests

Sometimes in the middle of a development, you may want to skip a test instead of
removing it or renaming it to prevent it from running. You can simply invoke the
==TestAsserter== message ==skip== on your test case instance. For example, the
following test uses it to define a conditional test.

[[[
OCCompiledMethodIntegrityTest >> testPragmas

	| newCompiledMethod originalCompiledMethod |
	(Smalltalk globals hasClassNamed: #Compiler) ifFalse: [ ^ self skip ].
	...
]]]

!!!! Continuing after a failure

SUnit also allows us to specify whether or not a test should continue after a
failure. This is a really powerful feature that uses Pharo's exception
mechanisms. To see what this can be used for, let's look at an example. Consider
the following test expression:

[[[
aCollection do: [ :each | self assert: each even ]
]]]

In this case, as soon as the test finds the first element of the collection that
isn't ==even==, the test stops. However, we would usually like to continue, and
see both how many elements, and which elements, aren't ==even== (and maybe also
log this information). You can do this as follows:

[[[
aCollection do: [ :each |
	self
		assert: each even
		description: each printString, ' is not even'
		resumable: true ]
]]]

This will print out a message on your logging stream for each element that
fails. It doesn't accumulate failures, i.e, if the assertion fails 10 times in
your test method, you'll still only see one failure. All the other assertion
methods that we have seen are not resumable by default;
==assert: p description: s== is equivalent to
==assert: p description: s resumable: false==.




